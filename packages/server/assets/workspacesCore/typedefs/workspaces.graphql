extend type Query {
  workspace(id: String!): Workspace!
    @hasServerRole(role: SERVER_USER)
    @hasScope(scope: "workspace:read")

  """
  Look for an invitation to a workspace, for the current user (authed or not). If token
  isn't specified, the server will look for any valid invite.

  If token is specified, it will return the corresponding invite even if it belongs to a different user.
  """
  workspaceInvite(workspaceId: String!, token: String): PendingWorkspaceCollaborator
}

input WorkspaceCreateInput {
  name: String!
  description: String
}

input WorkspaceUpdateInput {
  id: String!
  name: String
  description: String
  """
  Logo image as base64-encoded string
  """
  logo: String
}

input WorkspaceRoleUpdateInput {
  userId: String!
  workspaceId: String!
  """
  Leave role null to revoke access entirely
  """
  role: String
}

input WorkspaceRoleDeleteInput {
  userId: String!
  workspaceId: String!
}

input WorkspaceProjectInviteCreateInput {
  """
  Either this or userId must be filled
  """
  email: String
  """
  Either this or email must be filled
  """
  userId: String
  """
  Defaults to the contributor role, if not specified
  """
  role: String
  """
  Can only be specified if guest mode is on or if the user is an admin
  """
  serverRole: String
  """
  Only taken into account, if project belongs to a workspace. Defaults to guest access.
  """
  workspaceRole: String
}

input AddDomainToWorkspaceInput {
  domain: String!
  workspaceId: ID!
}

extend type ProjectInviteMutations {
  """
  Create invite(-s) for a project in a workspace. Unlike the base create() mutation, this allows
  configuring the workspace role.
  """
  createForWorkspace(
    projectId: ID!
    inputs: [WorkspaceProjectInviteCreateInput!]!
  ): Project! @hasScope(scope: "users:invite") @hasServerRole(role: SERVER_USER)
}

extend type Mutation {
  workspaceMutations: WorkspaceMutations! @hasServerRole(role: SERVER_USER)
}

type WorkspaceMutations {
  create(input: WorkspaceCreateInput!): Workspace!
    @hasServerRole(role: SERVER_USER)
    @hasScope(scope: "workspace:create")
  delete(workspaceId: String!): Boolean! @hasScope(scope: "workspace:delete")
  update(input: WorkspaceUpdateInput!): Workspace! @hasScope(scope: "workspace:update")
  updateRole(input: WorkspaceRoleUpdateInput!): Workspace!
    @hasScope(scope: "workspace:update")
  invites: WorkspaceInviteMutations!
  # TODO: this mutation should have an hasWorkspaceRole directive to authorize only workspace admin
  # We are, for the moment, doing the check in the resolver
  addDomain(input: AddDomainToWorkspaceInput!): Workspace!
    @hasScope(scope: "workspace:update")
}

input WorkspaceInviteCreateInput {
  """
  Either this or userId must be filled
  """
  email: String
  """
  Either this or email must be filled
  """
  userId: String
  """
  Defaults to the member role, if not specified
  """
  role: WorkspaceRole
}

input WorkspaceInviteUseInput {
  token: String!
  accept: Boolean!
}

type WorkspaceInviteMutations {
  create(workspaceId: String!, input: WorkspaceInviteCreateInput!): Workspace!
    @hasScope(scope: "users:invite")
    @hasServerRole(role: SERVER_USER)
  batchCreate(workspaceId: String!, input: [WorkspaceInviteCreateInput!]!): Workspace!
    @hasScope(scope: "users:invite")
    @hasServerRole(role: SERVER_USER)
  use(input: WorkspaceInviteUseInput!): Boolean!
  cancel(workspaceId: String!, inviteId: String!): Workspace!
    @hasScope(scope: "users:invite")
    @hasServerRole(role: SERVER_USER)
}

type Workspace {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  """
  Logo image as base64-encoded string
  """
  logo: String
  """
  Verified workspace domains
  """
  domains: [WorkspaceDomain!]! @hasWorkspaceRole(role: ADMIN)
  """
  Active user's role for this workspace. `null` if request is not authenticated, or the workspace is not explicitly shared with you.
  """
  role: String
  team: [WorkspaceCollaborator!]!
  """
  Only available to workspace owners
  """
  invitedTeam: [PendingWorkspaceCollaborator!] @hasWorkspaceRole(role: ADMIN)
  projects(
    limit: Int! = 25
    cursor: String
    filter: WorkspaceProjectsFilter
  ): ProjectCollection!
}

type WorkspaceDomain {
  id: ID!
  domain: String!
}

input WorkspaceProjectsFilter {
  """
  Filter out projects by name
  """
  search: String
}

type WorkspaceCollaborator {
  id: ID!
  role: String!
  user: LimitedUser!
}

type PendingWorkspaceCollaborator {
  id: ID!
  inviteId: String!
  workspaceId: String!
  workspaceName: String!
  """
  E-mail address or name of the invited user
  """
  title: String!
  """
  Target workspace role
  """
  role: String!
  invitedBy: LimitedUser!
  """
  Set only if user is registered
  """
  user: LimitedUser
  """
  Only available if the active user is the pending workspace collaborator
  """
  token: String
}

type WorkspaceCollection {
  totalCount: Int!
  cursor: String
  items: [Workspace!]!
}

extend type User {
  """
  Get the workspaces for the user
  """
  workspaces(
    limit: Int! = 25
    cursor: String = null
    filter: UserWorkspacesFilter
  ): WorkspaceCollection! @isOwner

  """
  Get all invitations to workspaces that the active user has
  """
  workspaceInvites: [PendingWorkspaceCollaborator!]!
    @hasServerRole(role: SERVER_GUEST)
    @hasScope(scope: "workspace:read")
    @isOwner
}

extend type Project {
  workspace: Workspace
}

type ServerWorkspacesInfo {
  """
  This is a backend control variable for the workspaces feature set.
  Since workspaces need a backend logic to be enabled, this is not enough as a feature flag.
  """
  workspacesEnabled: Boolean!
}

extend type ServerInfo {
  workspaces: ServerWorkspacesInfo!
}

extend type AdminQueries {
  workspaceList(
    query: String
    limit: Int! = 25
    cursor: String = null
  ): WorkspaceCollection!
}

input UserWorkspacesFilter {
  search: String
}

type UserWorkspaceMutations {
  leave(id: ID!): Boolean!
}

extend type ActiveUserMutations {
  workspaceMutations: UserWorkspaceMutations
}
