
// TODO: This is messy because of interactions between how knex internals manage connections and the way we use `knex.raw` to prepare transactions
export const replicateQuery = <F extends (...args: any[]) => Promise<any>>(
  dbs: [Knex, ...Knex[]], // TODO: should only allow db instances, not transaction contexts!
  factory: ({ db }: { db: Knex }) => F
): RegionalOperation<F> => {
  return (async (...params: Parameters<F>) => {
    if (dbs.length === 1) {
      return factory({ db: dbs[0] })(...params) as Promise<ReturnType<F>>
    }

    const returnValues: ReturnType<F>[] = []
    const preparedTransactionId = cryptoRandomString({ length: 10 })
    const preparedTransactions: {
      knex: Knex
      preparedTransactionId: string
    }[] = []
    const rollbackPreparedTransactions = async () =>
      Promise.allSettled(
        preparedTransactions.map(async ({ knex, preparedTransactionId }) => {
          await rollbackPreparedTransaction(knex, preparedTransactionId)
        })
      )

    // Every transaction is prepared
    // - if a query won't complete, every preparedTransaction is rollbacked (from prepared or unprepared)
    // - this applies a lock on the rows to be updated to assure that the commit will succeed.
    // - the transactions once prepared, gets written to disk db and is no longer scoped to the connection.
    // - this last part knex does not handle well, so no matter what, we need to rollback/commit
    // the transaction (the prepared one and the connection transaction) that's why it's wrapped in a transaction block

    try {
      console.log(`- ${preparedTransactionId} [start] [${dbs.length}]`)
      for (const db of dbs) {
        await db.transaction(async (trx) => {
          console.log(`- ${preparedTransactionId} \t ${dbs.indexOf(db)} \t tsx`)
          returnValues.push(await factory({ db: trx })(...params))
          console.log(`- ${preparedTransactionId} \t ${dbs.indexOf(db)} \t val`)
          await prepareTransaction(trx, preparedTransactionId)
          console.log(`- ${preparedTransactionId} \t ${dbs.indexOf(db)} \t pre`)
          preparedTransactions.push({ knex: db, preparedTransactionId })
        })
      }

      console.log(`- ${preparedTransactionId} [prepared]`)
    } catch (e) {
      console.log(`- ${preparedTransactionId} safe rollback!`)
      await rollbackPreparedTransactions()

      throw e
    }

    console.log(`- ${preparedTransactionId} [commiting]`)

    // Commit all prepared transactions
    const results = await Promise.allSettled(
      preparedTransactions.map(({ knex, preparedTransactionId }) =>
        commitPreparedTransaction(knex, preparedTransactionId)
      )
    )

    console.log(`- ${preparedTransactionId} [commited]`)

    const errors = results.filter((result): result is PromiseRejectedResult => {
      return result.status === PromiseAllSettledResultStatus.rejected
    })

    if (errors.length > 0) {
      // Theoretically, we never should reach this point, as once a transaction is prepared successfully, it will commit.
      logger.error(
        {
          params,
          errors,
          errorCount: errors.length,
          resultCount: results.length
        },
        `Failed {errorCount} of {resultCount} transactions in 2PC operation.`
      )

      console.log(`- ${preparedTransactionId} FATAL`)
      await rollbackPreparedTransactions()

      throw new RegionalTransactionFatalError(
        'Failed some or all transactions in 2PC operation.',
        preparedTransactions
      )
    }

    // this wont have any effect but knex releases the connection in a suc
    console.log(`- ${preparedTransactionId} [end]`)

    // DEBUG: DELETE!
    const a = (k: Knex) => ({
      free: numberOfFreeConnections(k),
      pool: {
        free: k.client.pool.numFree(),
        used: k.client.pool.numUsed(),
        aq: k.client.pool.numPendingAcquires(),
        cr: k.client.pool.numPendingCreates(),
        val: k.client.pool.numPendingValidations()
      }
    })

    const t = {}
    for (const db of dbs) {
      // @ts-expect-error remove plis
      t[`${db.client.connectionSettings.connectionString}`] = a(db)
    }
    console.log(t)

    return returnValues.at(0) as F
  }) as unknown as RegionalOperation<F>
}
