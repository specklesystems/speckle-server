import { reduce } from 'lodash'
import {
  shouldBeHeadless,
  getPuppeteerUserDataDir,
  getChromiumExecutablePath
} from '../utils/env'
import type { Logger } from 'pino'
import { PuppeteerClientInterface } from '../clients/puppeteer'
import type { ObjectIdentifier } from '../domain/domain'

export type GetScreenshot = (
  params: ObjectIdentifier
) => Promise<{ [key: string]: string } | null>

export const getScreenshotFactory =
  (deps: {
    puppeteerClient: PuppeteerClientInterface
    logger: Logger
    serviceOrigin: string
  }): GetScreenshot =>
  async (params) => {
    const objectUrl = `${deps.serviceOrigin}/streams/${params.streamId}/objects/${params.objectId}`
    const launchParams = {
      //TODO as the launch params are touching environment variables, should they be dependency injected?
      headless: shouldBeHeadless(),
      userDataDir: getPuppeteerUserDataDir(),
      executablePath: getChromiumExecutablePath(),
      protocolTimeout: 360_000,
      // we trust the web content that is running, so can disable the sandbox
      // disabling the sandbox allows us to run the docker image without linux kernel privileges
      args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
    }

    await deps.puppeteerClient.init(launchParams)

    type RenderOutput = {
      duration: number
      mem: { total: number }
      scr: { [key: string]: string }
    }
    type RenderErrorOutput = { error: unknown }
    let renderOutput: RenderOutput | RenderErrorOutput = {
      error: 'No response.'
    }
    try {
      // assume it is of type RenderOutput, and validate later
      renderOutput = <RenderOutput>(
        await deps.puppeteerClient.loadPageAndEvaluateScript(objectUrl)
      )
    } catch (err) {
      renderOutput = { error: err }
    } finally {
      // Don't await for cleanup
      deps.puppeteerClient.close()
    }

    if (
      typeof renderOutput === 'object' &&
      'error' in renderOutput &&
      renderOutput.error
    ) {
      deps.logger.error(renderOutput.error, 'Error generating preview.')
      return null
    } else if (
      typeof renderOutput !== 'object' ||
      !('scr' in renderOutput) ||
      !('duration' in renderOutput) ||
      !('mem' in renderOutput)
    ) {
      deps.logger.error(
        renderOutput,
        'Error generating preview. Expected output was not returned.'
      )
      return null
    }

    deps.logger.info(
      {
        durationSeconds: renderOutput.duration,
        totalMemoryMB: renderOutput.mem.total / 1000000,
        resultingImages: {
          count: Object.keys(renderOutput.scr || {}).length,
          totalStringSize: reduce(
            renderOutput.scr || {},
            (acc: number, val: string) => acc + val.length,
            0
          )
        }
      },
      `Generated preview.`
    )
    return renderOutput.scr

    // return `
    // <html><body>
    // <div>Generated by: ${ret.userAgent}</div>
    // <div>Duration in seconds: ${ret.duration}</div>
    // <div>Memory in MB: ${ret.mem.total / 1000000}</div>
    // <div>Used Memory in MB: ${ret.mem.used / 1000000}</div>
    // <img height="200px" src="${ret.scr['-2']}" /><br />
    // <img height="200px" src="${ret.scr['-1']}" /><br />
    // <img height="200px" src="${ret.scr['0']}" /><br />
    // <img height="200px" src="${ret.scr['1']}" /><br />
    // <img height="200px" src="${ret.scr['2']}" /><br />
    // </body></html>
    // `

    // const imageBuffer = new Buffer.from(
    //   b64Image.replace(/^data:image\/\w+;base64,/, ''),
    //   'base64'
    // )

    // // await page.waitForTimeout(500);
    // //var response = await page.screenshot({
    // //  type: 'png',
    // //  clip: {x: 0, y: 0, width: 800, height: 800}
    // //});

    // return imageBuffer
  }
