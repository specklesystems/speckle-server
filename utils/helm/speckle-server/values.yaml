namespace: speckle-test

domain: localhost
ssl_canonical_url: true

docker_image_tag: v2.3.3

db:
  # postgres_url: secret -> postgres_url
  useCertificate: false
  maxConnectionsServer: 4
  certificate: '' # Multi-line string with the contents of `ca-certificate.crt`
  PGSSLMODE: require
  networkPolicy: # if network policy is enabled for any service, this provides the networkPolicy with the necessary details to allow egress connections to the database
    port: '' # the port to connect to, if known (default: "5432")
    externalToCluster: # use if the database is external to the kubernetes cluster
      enabled: true # only one of externalToCluster or inCluster should be enabled, if both are enabled only inCluster is deployed
      host: '' # Domain name, or provide IP address.  If both are provided IP address takes precedence
      ipv4: '' # IP address of the externally hosted Database.  If not known, provide the host instead.  If both are provided the IP address takes precedence.
    inCluster: # use if the database is deployed within the same kubernetes cluster as Speckle
      enabled: false # only one of externalToCluster or inCluster should be enabled, if both are enabled only inCluster is deployed
      podSelector: {} # the selector to match with pod of the deployed database instance
      namespaceSelector: {} # the selector to match the namespace in which the database pod is deployed

s3:
  endpoint: ''
  bucket: ''
  access_key: ''
  create_bucket: 'false'
  region: '' # optional, defaults to 'us-east-1'
  # secret_key: secret -> s3_secret_key
  networkPolicy: # if network policy is enabled for any service, this provides the networkPolicy with the necessary details to allow egress connections to the s3 compatible storage
    externalToCluster: # use if the s3 compatible storage is external to the kubernetes cluster
      enabled: true # only one of externalToCluster or inCluster should be enabled, if both are enabled only inCluster is deployed
    inCluster: # use if the s3 compatible storage is deployed within the same kubernetes cluster as Speckle
      enabled: false # only one of externalToCluster or inCluster should be enabled, if both are enabled only inCluster is deployed
      podSelector: {} # the selector to match with pod of the deployed s3 compatible storage instance
      namespaceSelector: {} # the selector to match the namespace in which the s3 compatible storage pod is deployed

redis:
  # redis_url: secret -> redis_url
  networkPolicy: # if network policy is enabled for any service, this provides the networkPolicy with the necessary details to allow egress connections to redis
    port: '' # the port to connect to, if known (default: "6379")
    externalToCluster: # use if redis is external to the kubernetes cluster
      enabled: true # only one of externalToCluster or inCluster should be enabled, if both are enabled only inCluster is deployed
      host: '' # Domain name of the externally hosted Redis. It is preferable to provide the IP address.  If both are provided IP address takes precedence
      ipv4: '' # IP address of the externally hosted Redis.  If not known, provide the host instead.  If both are provided the IP address takes precedence.
    inCluster: # use if redis is deployed within the same kubernetes cluster as Speckle
      enabled: false # only one of externalToCluster or inCluster should be enabled, if both are enabled only inCluster is deployed
      podSelector: {} # the selector to match with pod of the deployed Redis instance
      namespaceSelector: {} # the selector to match the namespace in which the Redis pod is deployed

server:
  replicas: 1
  # session_secret: secret -> `session_secret`
  auth:
    local:
      enabled: true
    google:
      enabled: false
      client_id: ''
      # client_secret: secret -> `google_client_secret`
    github:
      enabled: false
      client_id: ''
      # client_secret: secret -> `github_client_secret`
    azure_ad:
      enabled: false
      org_name: ''
      identity_metadata: ''
      issuer: ''
      client_id: ''
      # client_secret: secret -> `azure_ad_client_secret`
  email:
    enabled: false
    host: ''
    port: ''
    username: ''
    # password: secret -> `email_password`
  requests:
    cpu: 500m
    memory: 1Gi
  limits:
    cpu: 1000m
    memory: 3Gi
  serviceAccount:
    create: true

  monitoring:
    apollo:
      enabled: false
      graph_id: ''
      # key: secret -> `apollo_key`

  # Sentry specific:
  sentry_dns: ''
  disable_tracking: false
  disable_tracing: false

  networkPolicy:
    enabled: false

frontend:
  replicas: 1
  requests:
    cpu: 250m
    memory: 256Mi
  limits:
    cpu: 1000m
    memory: 512Mi
  networkPolicy:
    enabled: false
  serviceAccount:
    create: true

preview_service:
  replicas: 1
  requests:
    cpu: 500m
    memory: 2Gi
  limits:
    cpu: 1000m
    memory: 4Gi
  networkPolicy:
    enabled: false
  serviceAccount:
    create: true

webhook_service:
  replicas: 1
  requests:
    cpu: 100m
    memory: 256Mi
  limits:
    cpu: 200m
    memory: 512Mi
  networkPolicy:
    enabled: false
  serviceAccount:
    create: true

fileimport_service:
  replicas: 1
  requests:
    cpu: 100m
    memory: 512Mi
  limits:
    cpu: 1000m
    memory: 2Gi
  serviceAccount:
    create: true
  time_limit_min: 10
  networkPolicy:
    enabled: false

monitoring:
  replicas: 1
  requests:
    cpu: 100m
    memory: 64Mi
  limits:
    cpu: 200m
    memory: 512Mi
  networkPolicy:
    enabled: false
  serviceAccount:
    create: true

test:
  requests:
    cpu: 100m
    memory: 64Mi
  limits:
    cpu: 200m
    memory: 512Mi
  networkPolicy:
    enabled: false
  serviceAccount:
    create: true

secretName: server-vars

enable_prometheus_monitoring: false
prometheusMonitoring:
  namespace: ''
  release: ''
cert_manager_issuer: letsencrypt-staging

helm_test_enabled: true

create_namespace: false
file_size_limit_mb: 100
imagePullPolicy: IfNotPresent

ingress:
  namespace: ingress-nginx
  controllerName: ingress-nginx
